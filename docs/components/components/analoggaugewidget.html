<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>controlunit.components.analoggaugewidget API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>controlunit.components.analoggaugewidget</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

###
# Author: Stefan Holstein
# inspired by: https://github.com/Werkov/PyQt4/blob/master/examples/widgets/analogclock.py
# Thanks to https://stackoverflow.com/
#
# Sorry for mixing english &amp; german notes
#
# ToDo: Fix Bug: Rundungsfehler Max Value / Grid
# ToDo: mehrere Zeiger ermöglichen. z.b. über ein ZeigerArray mit allen valiablen
#       Signal erzeugung (self.valueChange.emit()) pruefen wie es dann möglich ist.
#       Evtl MausTracking(Teil)-deaktivieren
#       Farben separat handeln
# todo: aktuell ist nur eine Zeigerrichtung klein nach gross im Uhrzeigersinn moeglich
# -&gt; erweiterung Anzeige von gross nach klein um Uhrzeigersin
# todo: auf timer event verzichten um effizienz zu steigern
#       self.update() an allen stellen einfügen, an denen es notwendig ist.
#       It is possible to En-/disable timerevents. Use: self.use_timer_event = True/False
# todo: Bug Fix: Offset Berechnung bezogen auf den Winkel ist falsch
# Todo: print() in logging() ausgabe aendern
###

import math

try:
    # print(&#34;trying to import Qt4 @ analoggaugewidget.py&#34;)
    # from PyQt4.QtGui import QMainWindow
    # from PyQt4.QtGui import QApplication
    from PyQt4.QtGui import (
        QPolygon,
        QPolygonF,
        QColor,
        QPen,
        QFont,
        QWidget,
        QPainter,
        QFontMetrics,
        QConicalGradient,
    )

    # QtGui -&gt; QPolygon, QPolygonF, QColor, QPen, QFont,
    #       -&gt; QWidget
    #       -&gt; QApplication

    from PyQt4.QtCore import (
        Qt,
        QTimer,
        QPoint,
        QPointF,
    )  # , SIGNAL, QRect, QSize, QTime
    from PyQt4.QtCore import QObject, pyqtSignal

    # QtCore -&gt; Qt.NoPen, QTime, QTimer, QPoint, QPointF, QRect, QSize

    used_Qt_Version = 4
    print(&#34;end trying to import Qt4 @ analoggaugewidget.py&#34;)
    # Antialysing may be problem with Qt4
    print(&#34;ToDo: Fix error output QPainter.Antialiasing&#34;)

except:
    try:
        # print(&#34;Try5: analoggaugewidget.py&#34;)
        # from PyQt5.QtWidgets import QMainWindow
        # from PyQt5.QtWidgets import QWidget
        # from PyQt5.QtWidgets import QApplication
        from PyQt5.QtWidgets import QWidget, QSizePolicy

        # QtWidgets -&gt; QWidget
        # QtWidgets -&gt; QApplication

        from PyQt5.QtGui import QPolygon, QPolygonF, QColor, QPen, QFont
        from PyQt5.QtGui import QPainter, QFontMetrics, QConicalGradient

        # QtGui -&gt; QPolygon, QPolygonF, QColor, QPen, QFont, QPainter, QFontMetrics, QConicalGradient

        from PyQt5.QtCore import Qt, QTime, QTimer, QPoint, QPointF, QRect, QSize
        from PyQt5.QtCore import QObject, pyqtSignal

        # QtCore -&gt; Qt.NoPen ,QTime, QTimer, QPoint, QPointF, QRect, QSize

        used_Qt_Version = 5
        print(&#34;end trying to import Qt5 @ analoggaugewidget.py&#34;)
    except Exception as e:
        print(&#34;Error Import Qt 4 &amp; 5 @ analoggaugewidget.py&#34;, f&#34;{e}&#34;)
        exit()

##########################################
# todo: Dokumentieren
##########################################


class AnalogGaugeWidget(QWidget):
    &#34;&#34;&#34;Fetches rows from a Bigtable.
    Args: 
        none
    
    &#34;&#34;&#34;

    valueChanged = pyqtSignal(int)

    def __init__(self, parent=None):
        super(AnalogGaugeWidget, self).__init__(parent)

        self.use_timer_event = False
        self.black = QColor(0, 0, 0, 255)
        # Set the relative position of the center
        # self.width * self.cp0[0], self.hight * self.cp0[1]
        self.cp0 = [0.5, 0.9]
        sizePolicy = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy.setHeightForWidth(True)
        self.setSizePolicy(sizePolicy)

        # self.valueColor = QColor(50, 50, 50, 255)
        # self.set_valueColor(50, 50, 50, 255)
        # self.NeedleColor = QColor(50, 50, 50, 255)
        self.set_NeedleColor(50, 50, 50, 255)
        self.NeedleColorReleased = self.NeedleColor
        # self.NeedleColorDrag = QColor(255, 0, 00, 255)
        self.set_NeedleColorDrag(255, 0, 00, 255)

        self.set_ScaleValueColor(50, 50, 50, 255)
        self.set_DisplayValueColor(50, 50, 50, 255)

        # self.CenterPointColor = QColor(50, 50, 50, 255)
        self.set_CenterPointColor(50, 50, 50, 255)

        # self.valueColor = black
        # self.black = QColor(0, 0, 0, 255)

        self.value_needle_count = 1
        self.value_needle = QObject
        self.change_value_needle_style(
            [
                QPolygon(
                    [
                        QPoint(4, 4),
                        QPoint(-4, 4),
                        QPoint(-3, -120),
                        QPoint(0, -126),
                        QPoint(3, -120),
                    ]
                )
            ]
        )

        self.value_min = 0
        self.value_max = 1000
        self.value = self.value_min
        self.value_offset = 0
        self.value_needle_snapzone = 0.05
        self.last_value = 0

        # self.value2 = 0
        # self.value2Color = QColor(0, 0, 0, 255)

        self.gauge_color_outer_radius_factor = 1
        self.gauge_color_inner_radius_factor = 0.95
        self.center_horizontal_value = 0
        self.center_vertical_value = 0
        self.debug1 = None
        self.debug2 = None
        self.scale_angle_start_value = 135
        self.scale_angle_size = 270
        self.angle_offset = 0

        # self.scala_main_count = 10
        self.set_scala_main_count(int(400 / 50))
        self.scala_subdiv_count = 5

        self.pen = QPen(QColor(0, 0, 0))
        self.font = QFont(&#34;Decorative&#34;, 20)

        self.scale_polygon_colors = []
        self.set_scale_polygon_colors(
            [[0.00, Qt.red], [0.1, Qt.yellow], [0.15, Qt.green], [1, Qt.transparent]]
        )

        # initialize Scale value text
        # self.enable_scale_text = True
        self.set_enable_ScaleText(True)
        self.scale_fontname = &#34;Decorative&#34;
        self.initial_scale_fontsize = 15
        self.scale_fontsize = self.initial_scale_fontsize

        # initialize Main value text
        self.enable_value_text = True
        self.value_fontname = &#34;Decorative&#34;
        self.initial_value_fontsize = 40
        self.value_fontsize = self.initial_value_fontsize
        self.text_radius_factor = 0.5

        # En/disable scale / fill
        # self.enable_barGraph = True
        self.set_enable_barGraph(True)
        # self.enable_filled_Polygon = True
        self.set_enable_filled_Polygon(True)

        self.enable_CenterPoint = True
        self.enable_fine_scaled_marker = True
        self.enable_big_scaled_marker = True

        self.needle_scale_factor = 0.8
        self.enable_Needle_Polygon = True

        # necessary for resize
        self.setMouseTracking(False)

        # QTimer sorgt fur neu Darstellung alle X ms
        # evtl performance hier verbessern mit self.update() und self.use_timer_event = False
        # todo: self.update als default ohne ueberpruefung, ob self.use_timer_event gesetzt ist oder nicht
        # Timer startet alle 10ms das event paintEvent
        if self.use_timer_event:
            timer = QTimer(self)
            timer.timeout.connect(self.update)
            timer.start(10)
        else:
            self.update()

        self.setWindowTitle(&#34;Analog Gauge&#34;)

        # self.connect(self, SIGNAL(&#34;resize()&#34;), self.rescaleMethod)

        # self.resize(300 , 300)
        self.rescale_method()

    def rescale_method(self):
        # print(&#34;slotMethod&#34;)
        ysize = 1.7 * self.height()
        if self.width() &lt;= ysize:
            self.widget_diameter = self.width()
        else:
            self.widget_diameter = ysize

        self.change_value_needle_style(
            [
                QPolygon(
                    [
                        QPoint(4, 30),
                        QPoint(-4, 30),
                        QPoint(
                            -2, -self.widget_diameter / 2 * self.needle_scale_factor
                        ),
                        QPoint(
                            0, -self.widget_diameter / 2 * self.needle_scale_factor - 6
                        ),
                        QPoint(2, -self.widget_diameter / 2 * self.needle_scale_factor),
                    ]
                )
            ]
        )
        # needle = [QPolygon([
        #     QPoint(4, 4),
        #     QPoint(-4, 4),
        #     QPoint(-3, -120),
        #     QPoint(0, -126),
        #     QPoint(3, -120)])]
        # print(str(type(needle)).split(&#34;&#39;&#34;)[1])
        #
        # needle = [2]
        # print(str(type(needle[0])).split(&#34;&#39;&#34;)[1])

        self.scale_fontsize = self.initial_scale_fontsize * self.widget_diameter / 250
        self.value_fontsize = self.initial_value_fontsize * self.widget_diameter / 400

        # print(&#34;slotMethod end&#34;)
        pass

    def change_value_needle_style(self, design):
        # prepared for multiple needle instrument
        self.value_needle = []
        for i in design:
            self.value_needle.append(i)
        if not self.use_timer_event:
            self.update()

    def update_value(self, value, mouse_controlled=False):
        # if not mouse_controlled:
        #     self.value = value
        #
        # if mouse_controlled:
        #     self.valueChanged.emit(int(value))

        if value &lt;= self.value_min:
            self.value = self.value_min
        elif value &gt;= self.value_max:
            self.value = self.value_max
        else:
            self.value = value
        # self.paintEvent(&#34;&#34;)
        self.valueChanged.emit(int(value))
        # print(self.value)

        # ohne timer: aktiviere self.update()
        if not self.use_timer_event:
            self.update()

    def update_angle_offset(self, offset):
        self.angle_offset = offset
        if not self.use_timer_event:
            self.update()

    def center_horizontal(self, value):
        self.center_horizontal_value = value
        # print(&#34;horizontal: &#34; + str(self.center_horizontal_value))

    def center_vertical(self, value):
        self.center_vertical_value = value
        # print(&#34;vertical: &#34; + str(self.center_vertical_value))

    ##########################################################################
    # Set Methods
    ##########################################################################
    def set_NeedleColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.NeedleColor = QColor(R, G, B, Transparency)
        self.NeedleColorReleased = self.NeedleColor

        if not self.use_timer_event:
            self.update()

    def set_NeedleColorDrag(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.NeedleColorDrag = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_ScaleValueColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.ScaleValueColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_DisplayValueColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.DisplayValueColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_CenterPointColor(self, R=50, G=50, B=50, Transparency=255):
        self.CenterPointColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_enable_Needle_Polygon(self, enable=True):
        self.enable_Needle_Polygon = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_ScaleText(self, enable=True):
        self.enable_scale_text = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_barGraph(self, enable=True):
        self.enable_barGraph = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_value_text(self, enable=True):
        self.enable_value_text = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_CenterPoint(self, enable=True):
        self.enable_CenterPoint = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_filled_Polygon(self, enable=True):
        self.enable_filled_Polygon = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_big_scaled_grid(self, enable=True):
        self.enable_big_scaled_marker = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_fine_scaled_marker(self, enable=True):
        self.enable_fine_scaled_marker = enable

        if not self.use_timer_event:
            self.update()

    def set_scala_main_count(self, count):
        if count &lt; 1:
            count = 1
        self.scala_main_count = count

        if not self.use_timer_event:
            self.update()

    def set_MinValue(self, min):
        if self.value &lt; min:
            self.value = min
        if min &gt;= self.value_max:
            self.value_min = self.value_max - 1
        else:
            self.value_min = min

        if not self.use_timer_event:
            self.update()

    def set_MaxValue(self, max):
        if self.value &gt; max:
            self.value = max
        if max &lt;= self.value_min:
            self.value_max = self.value_min + 1
        else:
            self.value_max = max

        if not self.use_timer_event:
            self.update()

    def set_start_scale_angle(self, value):
        # Value range in DEG: 0 - 360
        self.scale_angle_start_value = value
        # print(&#34;startFill: &#34; + str(self.scale_angle_start_value))

        if not self.use_timer_event:
            self.update()

    def set_total_scale_angle_size(self, value):
        self.scale_angle_size = value
        # print(&#34;stopFill: &#34; + str(self.scale_angle_size))

        if not self.use_timer_event:
            self.update()

    def set_gauge_color_outer_radius_factor(self, value):
        self.gauge_color_outer_radius_factor = float(value) / 1000
        # print(self.gauge_color_outer_radius_factor)

        if not self.use_timer_event:
            self.update()

    def set_gauge_color_inner_radius_factor(self, value):
        self.gauge_color_inner_radius_factor = float(value) / 1000
        # print(self.gauge_color_inner_radius_factor)

        if not self.use_timer_event:
            self.update()

    def set_scale_polygon_colors(self, color_array):
        # print(type(color_array))
        if &#34;list&#34; in str(type(color_array)):
            self.scale_polygon_colors = color_array
        elif color_array == None:
            self.scale_polygon_colors = [[0.0, Qt.transparent]]
        else:
            self.scale_polygon_colors = [[0.0, Qt.transparent]]

        if not self.use_timer_event:
            self.update()

    ###########################################################################
    # Get Methods
    ###########################################################################

    def get_value_max(self):
        return self.value_max

    ###########################################################################
    # Painter
    ###########################################################################

    def create_polygon_pie(self, outer_radius, inner_raduis, start, lenght):
        polygon_pie = QPolygonF()
        # start = self.scale_angle_start_value
        # start = 0
        # lenght = self.scale_angle_size
        # lenght = 180
        # inner_raduis = self.width()/4
        # print(start)
        n = 360  # angle steps size for full circle
        # changing n value will causes drawing issues
        w = 360 / n  # angle per step
        # create outer circle line from &#34;start&#34;-angle to &#34;start + lenght&#34;-angle
        x = 0
        y = 0

        # todo enable/disable bar graf here
        if not self.enable_barGraph:
            # float_value = ((lenght / (self.value_max - self.value_min)) * (self.value - self.value_min))
            lenght = int(
                round(
                    (lenght / (self.value_max - self.value_min))
                    * (self.value - self.value_min)
                )
            )
            # print(&#34;f: %s, l: %s&#34; %(float_value, lenght))
            pass

        # mymax = 0

        for i in range(lenght + 1):  # add the points of polygon
            t = w * i + start - self.angle_offset
            x = outer_radius * math.cos(math.radians(t))
            y = outer_radius * math.sin(math.radians(t))
            polygon_pie.append(QPointF(x, y))
        # create inner circle line from &#34;start + lenght&#34;-angle to &#34;start&#34;-angle
        for i in range(lenght + 1):  # add the points of polygon
            # print(&#34;2 &#34; + str(i))
            t = w * (lenght - i) + start - self.angle_offset
            x = inner_raduis * math.cos(math.radians(t))
            y = inner_raduis * math.sin(math.radians(t))
            polygon_pie.append(QPointF(x, y))

        # close outer line
        polygon_pie.append(QPointF(x, y))
        return polygon_pie

    def draw_filled_polygon(self, outline_pen_with=0):
        &#34;&#34;&#34; Draw color gradiate below the scale ticks
        &#34;&#34;&#34;
        if self.scale_polygon_colors == None:
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        painter.setPen(Qt.NoPen)

        self.pen.setWidth(outline_pen_with)
        if outline_pen_with &gt; 0:
            painter.setPen(self.pen)

        colored_scale_polygon = self.create_polygon_pie(
            ((self.widget_diameter / 2) - (self.pen.width() / 2))
            * self.gauge_color_outer_radius_factor,
            (
                ((self.widget_diameter / 2) - (self.pen.width() / 2))
                * self.gauge_color_inner_radius_factor
            ),
            self.scale_angle_start_value,
            self.scale_angle_size,
        )

        # gauge_rect seems to be unused.
        # gauge_rect = QRect(QPoint(0, 0), QSize(self.widget_diameter / 2 - 1, self.widget_diameter - 1))
        grad = QConicalGradient(
            QPointF(0, 0),
            -self.scale_angle_size
            - self.scale_angle_start_value
            + self.angle_offset
            - 1,
        )

        # todo definition scale color as array here
        for eachcolor in self.scale_polygon_colors:
            grad.setColorAt(*eachcolor)
        # grad.setColorAt(.00, Qt.red)
        # grad.setColorAt(.1, Qt.yellow)
        # grad.setColorAt(.15, Qt.green)
        # grad.setColorAt(1, Qt.transparent)
        painter.setBrush(grad)
        # self.brush = QBrush(QColor(255, 0, 255, 255))
        # painter.setBrush(self.brush)
        painter.drawPolygon(colored_scale_polygon)
        # return painter

    ###########################################################################
    # Scale Marker
    ###########################################################################

    def create_major_ticks(self):
        &#34;&#34;&#34;
        Painter of the major ticks
        &#34;&#34;&#34;
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        # painter.setPen(Qt.NoPen)
        # Major ticks color
        self.pen = QPen(QColor(0, 0, 0, 255))
        self.pen.setWidth(2)
        # # if outline_pen_with &gt; 0:
        painter.setPen(self.pen)

        painter.rotate(self.scale_angle_start_value - self.angle_offset)
        steps_size = float(self.scale_angle_size) / float(self.scala_main_count)
        scale_line_outer_start = self.widget_diameter / 2
        scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 20)
        # print(stepszize)
        for i in range(self.scala_main_count + 1):
            painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
            painter.rotate(steps_size)

    def create_major_ticks_labels(self):
        &#34;&#34;&#34;
        Draw major ticks labels
        &#34;&#34;&#34;
        painter = QPainter(self)
        # painter.setRenderHint(QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        # painter.save()
        font = QFont(self.scale_fontname, self.scale_fontsize)
        fm = QFontMetrics(font)

        pen_shadow = QPen()

        pen_shadow.setBrush(self.ScaleValueColor)
        painter.setPen(pen_shadow)

        # Scale ticks relative radius
        text_radius_factor = 0.75
        text_radius = self.widget_diameter / 2 * text_radius_factor

        scale_per_div = int((self.value_max - self.value_min) / self.scala_main_count)

        angle_distance = float(self.scale_angle_size) / float(self.scala_main_count)
        for i in range(self.scala_main_count + 1):
            # text = str(int((self.value_max - self.value_min) / self.scala_main_count * i))
            text = str(int(self.value_min + scale_per_div * i))
            w = fm.width(text) + 1
            h = fm.height()
            painter.setFont(QFont(self.scale_fontname, self.scale_fontsize))
            angle = angle_distance * i + float(
                self.scale_angle_start_value - self.angle_offset
            )
            x = text_radius * math.cos(math.radians(angle))
            y = text_radius * math.sin(math.radians(angle))
            # print(w, h, x, y, text)
            text = [
                x - int(w / 2),
                y - int(h / 2),
                int(w),
                int(h),
                Qt.AlignCenter,
                text,
            ]
            painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
        # painter.restore()

    def create_minor_ticks(self):
        #  Description_dict = 0
        painter = QPainter(self)

        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        painter.setPen(Qt.black)
        painter.rotate(self.scale_angle_start_value - self.angle_offset)
        steps_size = float(self.scale_angle_size) / float(
            self.scala_main_count * self.scala_subdiv_count
        )
        scale_line_outer_start = self.widget_diameter / 2
        scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 40)
        for i in range((self.scala_main_count * self.scala_subdiv_count) + 1):
            painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
            painter.rotate(steps_size)

    def create_digital_indicator(self):
        &#34;&#34;&#34; Main value indicator inside the Gauge &#34;&#34;&#34;
        painter = QPainter(self)
        # painter.setRenderHint(QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        # Place the coordinate origin in the center
        painter.translate(*self.center_p())
        # painter.save()
        # xShadow = 3.0
        # yShadow = 3.0
        font = QFont(self.value_fontname, self.value_fontsize)
        fm = QFontMetrics(font)

        pen_shadow = QPen()

        pen_shadow.setBrush(self.DisplayValueColor)
        painter.setPen(pen_shadow)

        text_radius = self.widget_diameter / 2 * self.text_radius_factor

        # angle_distance = (float(self.scale_angle_size) / float(self.scala_main_count))
        # for i in range(self.scala_main_count + 1):
        text = str(int(self.value))
        w = fm.width(text) + 1
        h = fm.height()
        painter.setFont(QFont(self.value_fontname, self.value_fontsize))

        # Mitte zwischen Skalenstart und Skalenende:
        # Skalenende = Skalenanfang - 360 + Skalenlaenge
        # Skalenmitte = (Skalenende - Skalenanfang) / 2 + Skalenanfang
        angle_end = float(self.scale_angle_start_value + self.scale_angle_size - 360)
        angle = (
            angle_end - self.scale_angle_start_value
        ) / 2 + self.scale_angle_start_value

        x = text_radius * math.cos(math.radians(angle))
        y = text_radius * math.sin(math.radians(angle))
        # print(w, h, x, y, text)
        text = [x - int(w / 2), y - int(h / 2), int(w), int(h), Qt.AlignCenter, text]
        painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
        # painter.restore()

    def draw_center_point(self, diameter=30):
        painter = QPainter(self)
        # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        painter.setPen(Qt.NoPen)
        # painter.setPen(Qt.NoPen)
        painter.setBrush(self.CenterPointColor)
        # diameter = diameter # self.widget_diameter/6
        painter.drawEllipse(
            int(-diameter / 2), int(-diameter / 2), int(diameter), int(diameter)
        )

    def draw_border(self):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.translate(*self.center_p())
        painter.setPen(QPen(Qt.green, 3))
        x0, y0 = self.center_p()
        painter.drawRect(0 - x0, 0 - y0, self.width(), self.height())

    def center_p(self):
        &#34;&#34;&#34;
        Return the center position
        &#34;&#34;&#34;
        return [self.width() * self.cp0[0], self.height() * self.cp0[1]]

    def draw_needle(self):
        painter = QPainter(self)
        # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        painter.setPen(Qt.NoPen)
        painter.setBrush(self.NeedleColor)
        painter.rotate(
            (
                (self.value - self.value_offset - self.value_min)
                * self.scale_angle_size
                / (self.value_max - self.value_min)
            )
            + 90
            + self.scale_angle_start_value
        )

        painter.drawConvexPolygon(self.value_needle[0])

    ###########################################################################
    # Events
    ###########################################################################

    def resizeEvent(self, event):
        # self.resized.emit()
        # return super(self.parent, self).resizeEvent(event)
        # print(&#34;resized&#34;)
        # print(self.width())
        self.rescale_method()
        # self.emit(QtCore.SIGNAL(&#34;resize()&#34;))
        # print(&#34;resizeEvent&#34;)

    def paintEvent(self, event):
        # Main Drawing Event:
        # Will be executed on every change
        # vgl http://doc.qt.io/qt-4.8/qt-demos-affine-xform-cpp.html
        # print(&#34;event&#34;, event)

        # colored scale
        if self.enable_filled_Polygon:
            self.draw_filled_polygon()

        # draw scale ticks
        if self.enable_fine_scaled_marker:
            self.create_minor_ticks()
        if self.enable_big_scaled_marker:
            self.create_major_ticks()

        # draw tick labels
        if self.enable_scale_text:
            self.create_major_ticks_labels()

        # Display Value in the digital indicator
        if self.enable_value_text:
            self.create_digital_indicator()

        # draw needle 1
        if self.enable_Needle_Polygon:
            self.draw_needle()

        # Draw Center Point
        if self.enable_CenterPoint:
            self.draw_center_point(diameter=(self.widget_diameter / 6))

        # Draw border of the widget
        # self.draw_border()

    ###########################################################################
    # MouseEvents
    ###########################################################################

    def setMouseTracking(self, flag):
        def recursive_set(parent):
            for child in parent.findChildren(QObject):
                try:
                    child.setMouseTracking(flag)
                except:
                    pass
                recursive_set(child)

        QWidget.setMouseTracking(self, flag)
        recursive_set(self)

    def mouseReleaseEvent(self, QMouseEvent):
        # print(&#34;released&#34;)
        self.NeedleColor = self.NeedleColorReleased

        if not self.use_timer_event:
            self.update()
        pass

    def mouseMoveEvent(self, event):
        x, y = event.x() - (self.width() / 2), event.y() - (self.height() / 2)
        if not x == 0:
            angle = math.atan2(y, x) / math.pi * 180
            # winkellaenge der anzeige immer positiv 0 - 360deg
            # min wert + umskalierter wert
            value = (
                float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
                / (
                    float(self.scale_angle_size)
                    / float(self.value_max - self.value_min)
                )
            ) + self.value_min
            temp = value
            fmod = float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
            state = 0
            if (
                (
                    self.value
                    - (self.value_max - self.value_min) * self.value_needle_snapzone
                )
                &lt;= value
                &lt;= (
                    self.value
                    + (self.value_max - self.value_min) * self.value_needle_snapzone
                )
            ):
                self.NeedleColor = self.NeedleColorDrag
                # todo: evtl ueberpruefen
                #
                state = 9
                # if value &gt;= self.value_max and self.last_value &lt; (self.value_max - self.value_min) / 2:
                if (
                    value &gt;= self.value_max
                    and self.last_value &lt; (self.value_max - self.value_min) / 2
                ):
                    state = 1
                    value = self.value_max
                    self.last_value = self.value_min
                    self.valueChanged.emit(int(value))
                elif value &gt;= self.value_max &gt;= self.last_value:
                    state = 2
                    value = self.value_max
                    self.last_value = self.value_max
                    self.valueChanged.emit(int(value))
                else:
                    state = 3
                    self.last_value = value
                    self.valueChanged.emit(int(value))

                # todo: mouse event debug output

                # self.update_value(value, mouse_controlled=True)

                # self.valueChanged.emit(int(value))
                # print(str(int(value)))
            # self.valueChanged.emit()

            # todo: convert print to logging debug
            # print(&#39;mouseMoveEvent: x=%d, y=%d, a=%s, v=%s, fmod=%s, temp=%s, state=%s&#39; % (
            #     x, y, angle, value, fmod, temp, state))

    # def createPoly(self, n, r, s):
    #     polygon = QPolygonF()
    #
    #     w = 360/n                                                       # angle per step
    #     for i in range(n):                                              # add the points of polygon
    #         t = w*i + s
    #         x = r*math.cos(math.radians(t))
    #         y = r*math.sin(math.radians(t))
    #         # polygon.append(QtCore.QPointF(self.width()/2 +x, self.height()/2 + y))
    #         polygon.append(QtCore.QPointF(x, y))
    #
    #     return polygon


###############################################################################
# DEMO Routine
# required: analoggaugewidget_demo.ui
# compile analoggaugewidget_demo.ui -&gt; analoggaugewidget_demo_ui.py
# show a lot of variables and possibilities formodification
###############################################################################
if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget"><code class="flex name class">
<span>class <span class="ident">AnalogGaugeWidget</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches rows from a Bigtable.
Args:
none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalogGaugeWidget(QWidget):
    &#34;&#34;&#34;Fetches rows from a Bigtable.
    Args: 
        none
    
    &#34;&#34;&#34;

    valueChanged = pyqtSignal(int)

    def __init__(self, parent=None):
        super(AnalogGaugeWidget, self).__init__(parent)

        self.use_timer_event = False
        self.black = QColor(0, 0, 0, 255)
        # Set the relative position of the center
        # self.width * self.cp0[0], self.hight * self.cp0[1]
        self.cp0 = [0.5, 0.9]
        sizePolicy = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy.setHeightForWidth(True)
        self.setSizePolicy(sizePolicy)

        # self.valueColor = QColor(50, 50, 50, 255)
        # self.set_valueColor(50, 50, 50, 255)
        # self.NeedleColor = QColor(50, 50, 50, 255)
        self.set_NeedleColor(50, 50, 50, 255)
        self.NeedleColorReleased = self.NeedleColor
        # self.NeedleColorDrag = QColor(255, 0, 00, 255)
        self.set_NeedleColorDrag(255, 0, 00, 255)

        self.set_ScaleValueColor(50, 50, 50, 255)
        self.set_DisplayValueColor(50, 50, 50, 255)

        # self.CenterPointColor = QColor(50, 50, 50, 255)
        self.set_CenterPointColor(50, 50, 50, 255)

        # self.valueColor = black
        # self.black = QColor(0, 0, 0, 255)

        self.value_needle_count = 1
        self.value_needle = QObject
        self.change_value_needle_style(
            [
                QPolygon(
                    [
                        QPoint(4, 4),
                        QPoint(-4, 4),
                        QPoint(-3, -120),
                        QPoint(0, -126),
                        QPoint(3, -120),
                    ]
                )
            ]
        )

        self.value_min = 0
        self.value_max = 1000
        self.value = self.value_min
        self.value_offset = 0
        self.value_needle_snapzone = 0.05
        self.last_value = 0

        # self.value2 = 0
        # self.value2Color = QColor(0, 0, 0, 255)

        self.gauge_color_outer_radius_factor = 1
        self.gauge_color_inner_radius_factor = 0.95
        self.center_horizontal_value = 0
        self.center_vertical_value = 0
        self.debug1 = None
        self.debug2 = None
        self.scale_angle_start_value = 135
        self.scale_angle_size = 270
        self.angle_offset = 0

        # self.scala_main_count = 10
        self.set_scala_main_count(int(400 / 50))
        self.scala_subdiv_count = 5

        self.pen = QPen(QColor(0, 0, 0))
        self.font = QFont(&#34;Decorative&#34;, 20)

        self.scale_polygon_colors = []
        self.set_scale_polygon_colors(
            [[0.00, Qt.red], [0.1, Qt.yellow], [0.15, Qt.green], [1, Qt.transparent]]
        )

        # initialize Scale value text
        # self.enable_scale_text = True
        self.set_enable_ScaleText(True)
        self.scale_fontname = &#34;Decorative&#34;
        self.initial_scale_fontsize = 15
        self.scale_fontsize = self.initial_scale_fontsize

        # initialize Main value text
        self.enable_value_text = True
        self.value_fontname = &#34;Decorative&#34;
        self.initial_value_fontsize = 40
        self.value_fontsize = self.initial_value_fontsize
        self.text_radius_factor = 0.5

        # En/disable scale / fill
        # self.enable_barGraph = True
        self.set_enable_barGraph(True)
        # self.enable_filled_Polygon = True
        self.set_enable_filled_Polygon(True)

        self.enable_CenterPoint = True
        self.enable_fine_scaled_marker = True
        self.enable_big_scaled_marker = True

        self.needle_scale_factor = 0.8
        self.enable_Needle_Polygon = True

        # necessary for resize
        self.setMouseTracking(False)

        # QTimer sorgt fur neu Darstellung alle X ms
        # evtl performance hier verbessern mit self.update() und self.use_timer_event = False
        # todo: self.update als default ohne ueberpruefung, ob self.use_timer_event gesetzt ist oder nicht
        # Timer startet alle 10ms das event paintEvent
        if self.use_timer_event:
            timer = QTimer(self)
            timer.timeout.connect(self.update)
            timer.start(10)
        else:
            self.update()

        self.setWindowTitle(&#34;Analog Gauge&#34;)

        # self.connect(self, SIGNAL(&#34;resize()&#34;), self.rescaleMethod)

        # self.resize(300 , 300)
        self.rescale_method()

    def rescale_method(self):
        # print(&#34;slotMethod&#34;)
        ysize = 1.7 * self.height()
        if self.width() &lt;= ysize:
            self.widget_diameter = self.width()
        else:
            self.widget_diameter = ysize

        self.change_value_needle_style(
            [
                QPolygon(
                    [
                        QPoint(4, 30),
                        QPoint(-4, 30),
                        QPoint(
                            -2, -self.widget_diameter / 2 * self.needle_scale_factor
                        ),
                        QPoint(
                            0, -self.widget_diameter / 2 * self.needle_scale_factor - 6
                        ),
                        QPoint(2, -self.widget_diameter / 2 * self.needle_scale_factor),
                    ]
                )
            ]
        )
        # needle = [QPolygon([
        #     QPoint(4, 4),
        #     QPoint(-4, 4),
        #     QPoint(-3, -120),
        #     QPoint(0, -126),
        #     QPoint(3, -120)])]
        # print(str(type(needle)).split(&#34;&#39;&#34;)[1])
        #
        # needle = [2]
        # print(str(type(needle[0])).split(&#34;&#39;&#34;)[1])

        self.scale_fontsize = self.initial_scale_fontsize * self.widget_diameter / 250
        self.value_fontsize = self.initial_value_fontsize * self.widget_diameter / 400

        # print(&#34;slotMethod end&#34;)
        pass

    def change_value_needle_style(self, design):
        # prepared for multiple needle instrument
        self.value_needle = []
        for i in design:
            self.value_needle.append(i)
        if not self.use_timer_event:
            self.update()

    def update_value(self, value, mouse_controlled=False):
        # if not mouse_controlled:
        #     self.value = value
        #
        # if mouse_controlled:
        #     self.valueChanged.emit(int(value))

        if value &lt;= self.value_min:
            self.value = self.value_min
        elif value &gt;= self.value_max:
            self.value = self.value_max
        else:
            self.value = value
        # self.paintEvent(&#34;&#34;)
        self.valueChanged.emit(int(value))
        # print(self.value)

        # ohne timer: aktiviere self.update()
        if not self.use_timer_event:
            self.update()

    def update_angle_offset(self, offset):
        self.angle_offset = offset
        if not self.use_timer_event:
            self.update()

    def center_horizontal(self, value):
        self.center_horizontal_value = value
        # print(&#34;horizontal: &#34; + str(self.center_horizontal_value))

    def center_vertical(self, value):
        self.center_vertical_value = value
        # print(&#34;vertical: &#34; + str(self.center_vertical_value))

    ##########################################################################
    # Set Methods
    ##########################################################################
    def set_NeedleColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.NeedleColor = QColor(R, G, B, Transparency)
        self.NeedleColorReleased = self.NeedleColor

        if not self.use_timer_event:
            self.update()

    def set_NeedleColorDrag(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.NeedleColorDrag = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_ScaleValueColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.ScaleValueColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_DisplayValueColor(self, R=50, G=50, B=50, Transparency=255):
        # Red: R = 0 - 255
        # Green: G = 0 - 255
        # Blue: B = 0 - 255
        # Transparency = 0 - 255
        self.DisplayValueColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_CenterPointColor(self, R=50, G=50, B=50, Transparency=255):
        self.CenterPointColor = QColor(R, G, B, Transparency)

        if not self.use_timer_event:
            self.update()

    def set_enable_Needle_Polygon(self, enable=True):
        self.enable_Needle_Polygon = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_ScaleText(self, enable=True):
        self.enable_scale_text = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_barGraph(self, enable=True):
        self.enable_barGraph = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_value_text(self, enable=True):
        self.enable_value_text = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_CenterPoint(self, enable=True):
        self.enable_CenterPoint = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_filled_Polygon(self, enable=True):
        self.enable_filled_Polygon = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_big_scaled_grid(self, enable=True):
        self.enable_big_scaled_marker = enable

        if not self.use_timer_event:
            self.update()

    def set_enable_fine_scaled_marker(self, enable=True):
        self.enable_fine_scaled_marker = enable

        if not self.use_timer_event:
            self.update()

    def set_scala_main_count(self, count):
        if count &lt; 1:
            count = 1
        self.scala_main_count = count

        if not self.use_timer_event:
            self.update()

    def set_MinValue(self, min):
        if self.value &lt; min:
            self.value = min
        if min &gt;= self.value_max:
            self.value_min = self.value_max - 1
        else:
            self.value_min = min

        if not self.use_timer_event:
            self.update()

    def set_MaxValue(self, max):
        if self.value &gt; max:
            self.value = max
        if max &lt;= self.value_min:
            self.value_max = self.value_min + 1
        else:
            self.value_max = max

        if not self.use_timer_event:
            self.update()

    def set_start_scale_angle(self, value):
        # Value range in DEG: 0 - 360
        self.scale_angle_start_value = value
        # print(&#34;startFill: &#34; + str(self.scale_angle_start_value))

        if not self.use_timer_event:
            self.update()

    def set_total_scale_angle_size(self, value):
        self.scale_angle_size = value
        # print(&#34;stopFill: &#34; + str(self.scale_angle_size))

        if not self.use_timer_event:
            self.update()

    def set_gauge_color_outer_radius_factor(self, value):
        self.gauge_color_outer_radius_factor = float(value) / 1000
        # print(self.gauge_color_outer_radius_factor)

        if not self.use_timer_event:
            self.update()

    def set_gauge_color_inner_radius_factor(self, value):
        self.gauge_color_inner_radius_factor = float(value) / 1000
        # print(self.gauge_color_inner_radius_factor)

        if not self.use_timer_event:
            self.update()

    def set_scale_polygon_colors(self, color_array):
        # print(type(color_array))
        if &#34;list&#34; in str(type(color_array)):
            self.scale_polygon_colors = color_array
        elif color_array == None:
            self.scale_polygon_colors = [[0.0, Qt.transparent]]
        else:
            self.scale_polygon_colors = [[0.0, Qt.transparent]]

        if not self.use_timer_event:
            self.update()

    ###########################################################################
    # Get Methods
    ###########################################################################

    def get_value_max(self):
        return self.value_max

    ###########################################################################
    # Painter
    ###########################################################################

    def create_polygon_pie(self, outer_radius, inner_raduis, start, lenght):
        polygon_pie = QPolygonF()
        # start = self.scale_angle_start_value
        # start = 0
        # lenght = self.scale_angle_size
        # lenght = 180
        # inner_raduis = self.width()/4
        # print(start)
        n = 360  # angle steps size for full circle
        # changing n value will causes drawing issues
        w = 360 / n  # angle per step
        # create outer circle line from &#34;start&#34;-angle to &#34;start + lenght&#34;-angle
        x = 0
        y = 0

        # todo enable/disable bar graf here
        if not self.enable_barGraph:
            # float_value = ((lenght / (self.value_max - self.value_min)) * (self.value - self.value_min))
            lenght = int(
                round(
                    (lenght / (self.value_max - self.value_min))
                    * (self.value - self.value_min)
                )
            )
            # print(&#34;f: %s, l: %s&#34; %(float_value, lenght))
            pass

        # mymax = 0

        for i in range(lenght + 1):  # add the points of polygon
            t = w * i + start - self.angle_offset
            x = outer_radius * math.cos(math.radians(t))
            y = outer_radius * math.sin(math.radians(t))
            polygon_pie.append(QPointF(x, y))
        # create inner circle line from &#34;start + lenght&#34;-angle to &#34;start&#34;-angle
        for i in range(lenght + 1):  # add the points of polygon
            # print(&#34;2 &#34; + str(i))
            t = w * (lenght - i) + start - self.angle_offset
            x = inner_raduis * math.cos(math.radians(t))
            y = inner_raduis * math.sin(math.radians(t))
            polygon_pie.append(QPointF(x, y))

        # close outer line
        polygon_pie.append(QPointF(x, y))
        return polygon_pie

    def draw_filled_polygon(self, outline_pen_with=0):
        &#34;&#34;&#34; Draw color gradiate below the scale ticks
        &#34;&#34;&#34;
        if self.scale_polygon_colors == None:
            return

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        painter.setPen(Qt.NoPen)

        self.pen.setWidth(outline_pen_with)
        if outline_pen_with &gt; 0:
            painter.setPen(self.pen)

        colored_scale_polygon = self.create_polygon_pie(
            ((self.widget_diameter / 2) - (self.pen.width() / 2))
            * self.gauge_color_outer_radius_factor,
            (
                ((self.widget_diameter / 2) - (self.pen.width() / 2))
                * self.gauge_color_inner_radius_factor
            ),
            self.scale_angle_start_value,
            self.scale_angle_size,
        )

        # gauge_rect seems to be unused.
        # gauge_rect = QRect(QPoint(0, 0), QSize(self.widget_diameter / 2 - 1, self.widget_diameter - 1))
        grad = QConicalGradient(
            QPointF(0, 0),
            -self.scale_angle_size
            - self.scale_angle_start_value
            + self.angle_offset
            - 1,
        )

        # todo definition scale color as array here
        for eachcolor in self.scale_polygon_colors:
            grad.setColorAt(*eachcolor)
        # grad.setColorAt(.00, Qt.red)
        # grad.setColorAt(.1, Qt.yellow)
        # grad.setColorAt(.15, Qt.green)
        # grad.setColorAt(1, Qt.transparent)
        painter.setBrush(grad)
        # self.brush = QBrush(QColor(255, 0, 255, 255))
        # painter.setBrush(self.brush)
        painter.drawPolygon(colored_scale_polygon)
        # return painter

    ###########################################################################
    # Scale Marker
    ###########################################################################

    def create_major_ticks(self):
        &#34;&#34;&#34;
        Painter of the major ticks
        &#34;&#34;&#34;
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        # painter.setPen(Qt.NoPen)
        # Major ticks color
        self.pen = QPen(QColor(0, 0, 0, 255))
        self.pen.setWidth(2)
        # # if outline_pen_with &gt; 0:
        painter.setPen(self.pen)

        painter.rotate(self.scale_angle_start_value - self.angle_offset)
        steps_size = float(self.scale_angle_size) / float(self.scala_main_count)
        scale_line_outer_start = self.widget_diameter / 2
        scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 20)
        # print(stepszize)
        for i in range(self.scala_main_count + 1):
            painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
            painter.rotate(steps_size)

    def create_major_ticks_labels(self):
        &#34;&#34;&#34;
        Draw major ticks labels
        &#34;&#34;&#34;
        painter = QPainter(self)
        # painter.setRenderHint(QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        # painter.save()
        font = QFont(self.scale_fontname, self.scale_fontsize)
        fm = QFontMetrics(font)

        pen_shadow = QPen()

        pen_shadow.setBrush(self.ScaleValueColor)
        painter.setPen(pen_shadow)

        # Scale ticks relative radius
        text_radius_factor = 0.75
        text_radius = self.widget_diameter / 2 * text_radius_factor

        scale_per_div = int((self.value_max - self.value_min) / self.scala_main_count)

        angle_distance = float(self.scale_angle_size) / float(self.scala_main_count)
        for i in range(self.scala_main_count + 1):
            # text = str(int((self.value_max - self.value_min) / self.scala_main_count * i))
            text = str(int(self.value_min + scale_per_div * i))
            w = fm.width(text) + 1
            h = fm.height()
            painter.setFont(QFont(self.scale_fontname, self.scale_fontsize))
            angle = angle_distance * i + float(
                self.scale_angle_start_value - self.angle_offset
            )
            x = text_radius * math.cos(math.radians(angle))
            y = text_radius * math.sin(math.radians(angle))
            # print(w, h, x, y, text)
            text = [
                x - int(w / 2),
                y - int(h / 2),
                int(w),
                int(h),
                Qt.AlignCenter,
                text,
            ]
            painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
        # painter.restore()

    def create_minor_ticks(self):
        #  Description_dict = 0
        painter = QPainter(self)

        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())

        painter.setPen(Qt.black)
        painter.rotate(self.scale_angle_start_value - self.angle_offset)
        steps_size = float(self.scale_angle_size) / float(
            self.scala_main_count * self.scala_subdiv_count
        )
        scale_line_outer_start = self.widget_diameter / 2
        scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 40)
        for i in range((self.scala_main_count * self.scala_subdiv_count) + 1):
            painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
            painter.rotate(steps_size)

    def create_digital_indicator(self):
        &#34;&#34;&#34; Main value indicator inside the Gauge &#34;&#34;&#34;
        painter = QPainter(self)
        # painter.setRenderHint(QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        # Place the coordinate origin in the center
        painter.translate(*self.center_p())
        # painter.save()
        # xShadow = 3.0
        # yShadow = 3.0
        font = QFont(self.value_fontname, self.value_fontsize)
        fm = QFontMetrics(font)

        pen_shadow = QPen()

        pen_shadow.setBrush(self.DisplayValueColor)
        painter.setPen(pen_shadow)

        text_radius = self.widget_diameter / 2 * self.text_radius_factor

        # angle_distance = (float(self.scale_angle_size) / float(self.scala_main_count))
        # for i in range(self.scala_main_count + 1):
        text = str(int(self.value))
        w = fm.width(text) + 1
        h = fm.height()
        painter.setFont(QFont(self.value_fontname, self.value_fontsize))

        # Mitte zwischen Skalenstart und Skalenende:
        # Skalenende = Skalenanfang - 360 + Skalenlaenge
        # Skalenmitte = (Skalenende - Skalenanfang) / 2 + Skalenanfang
        angle_end = float(self.scale_angle_start_value + self.scale_angle_size - 360)
        angle = (
            angle_end - self.scale_angle_start_value
        ) / 2 + self.scale_angle_start_value

        x = text_radius * math.cos(math.radians(angle))
        y = text_radius * math.sin(math.radians(angle))
        # print(w, h, x, y, text)
        text = [x - int(w / 2), y - int(h / 2), int(w), int(h), Qt.AlignCenter, text]
        painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
        # painter.restore()

    def draw_center_point(self, diameter=30):
        painter = QPainter(self)
        # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)

        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        painter.setPen(Qt.NoPen)
        # painter.setPen(Qt.NoPen)
        painter.setBrush(self.CenterPointColor)
        # diameter = diameter # self.widget_diameter/6
        painter.drawEllipse(
            int(-diameter / 2), int(-diameter / 2), int(diameter), int(diameter)
        )

    def draw_border(self):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.translate(*self.center_p())
        painter.setPen(QPen(Qt.green, 3))
        x0, y0 = self.center_p()
        painter.drawRect(0 - x0, 0 - y0, self.width(), self.height())

    def center_p(self):
        &#34;&#34;&#34;
        Return the center position
        &#34;&#34;&#34;
        return [self.width() * self.cp0[0], self.height() * self.cp0[1]]

    def draw_needle(self):
        painter = QPainter(self)
        # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
        painter.setRenderHint(QPainter.Antialiasing)
        # Koordinatenursprung in die Mitte der Flaeche legen
        painter.translate(*self.center_p())
        painter.setPen(Qt.NoPen)
        painter.setBrush(self.NeedleColor)
        painter.rotate(
            (
                (self.value - self.value_offset - self.value_min)
                * self.scale_angle_size
                / (self.value_max - self.value_min)
            )
            + 90
            + self.scale_angle_start_value
        )

        painter.drawConvexPolygon(self.value_needle[0])

    ###########################################################################
    # Events
    ###########################################################################

    def resizeEvent(self, event):
        # self.resized.emit()
        # return super(self.parent, self).resizeEvent(event)
        # print(&#34;resized&#34;)
        # print(self.width())
        self.rescale_method()
        # self.emit(QtCore.SIGNAL(&#34;resize()&#34;))
        # print(&#34;resizeEvent&#34;)

    def paintEvent(self, event):
        # Main Drawing Event:
        # Will be executed on every change
        # vgl http://doc.qt.io/qt-4.8/qt-demos-affine-xform-cpp.html
        # print(&#34;event&#34;, event)

        # colored scale
        if self.enable_filled_Polygon:
            self.draw_filled_polygon()

        # draw scale ticks
        if self.enable_fine_scaled_marker:
            self.create_minor_ticks()
        if self.enable_big_scaled_marker:
            self.create_major_ticks()

        # draw tick labels
        if self.enable_scale_text:
            self.create_major_ticks_labels()

        # Display Value in the digital indicator
        if self.enable_value_text:
            self.create_digital_indicator()

        # draw needle 1
        if self.enable_Needle_Polygon:
            self.draw_needle()

        # Draw Center Point
        if self.enable_CenterPoint:
            self.draw_center_point(diameter=(self.widget_diameter / 6))

        # Draw border of the widget
        # self.draw_border()

    ###########################################################################
    # MouseEvents
    ###########################################################################

    def setMouseTracking(self, flag):
        def recursive_set(parent):
            for child in parent.findChildren(QObject):
                try:
                    child.setMouseTracking(flag)
                except:
                    pass
                recursive_set(child)

        QWidget.setMouseTracking(self, flag)
        recursive_set(self)

    def mouseReleaseEvent(self, QMouseEvent):
        # print(&#34;released&#34;)
        self.NeedleColor = self.NeedleColorReleased

        if not self.use_timer_event:
            self.update()
        pass

    def mouseMoveEvent(self, event):
        x, y = event.x() - (self.width() / 2), event.y() - (self.height() / 2)
        if not x == 0:
            angle = math.atan2(y, x) / math.pi * 180
            # winkellaenge der anzeige immer positiv 0 - 360deg
            # min wert + umskalierter wert
            value = (
                float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
                / (
                    float(self.scale_angle_size)
                    / float(self.value_max - self.value_min)
                )
            ) + self.value_min
            temp = value
            fmod = float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
            state = 0
            if (
                (
                    self.value
                    - (self.value_max - self.value_min) * self.value_needle_snapzone
                )
                &lt;= value
                &lt;= (
                    self.value
                    + (self.value_max - self.value_min) * self.value_needle_snapzone
                )
            ):
                self.NeedleColor = self.NeedleColorDrag
                # todo: evtl ueberpruefen
                #
                state = 9
                # if value &gt;= self.value_max and self.last_value &lt; (self.value_max - self.value_min) / 2:
                if (
                    value &gt;= self.value_max
                    and self.last_value &lt; (self.value_max - self.value_min) / 2
                ):
                    state = 1
                    value = self.value_max
                    self.last_value = self.value_min
                    self.valueChanged.emit(int(value))
                elif value &gt;= self.value_max &gt;= self.last_value:
                    state = 2
                    value = self.value_max
                    self.last_value = self.value_max
                    self.valueChanged.emit(int(value))
                else:
                    state = 3
                    self.last_value = value
                    self.valueChanged.emit(int(value))

                # todo: mouse event debug output

                # self.update_value(value, mouse_controlled=True)

                # self.valueChanged.emit(int(value))
                # print(str(int(value)))
            # self.valueChanged.emit()

            # todo: convert print to logging debug
            # print(&#39;mouseMoveEvent: x=%d, y=%d, a=%s, v=%s, fmod=%s, temp=%s, state=%s&#39; % (
            #     x, y, angle, value, fmod, temp, state))

    # def createPoly(self, n, r, s):
    #     polygon = QPolygonF()
    #
    #     w = 360/n                                                       # angle per step
    #     for i in range(n):                                              # add the points of polygon
    #         t = w*i + s
    #         x = r*math.cos(math.radians(t))
    #         y = r*math.sin(math.radians(t))
    #         # polygon.append(QtCore.QPointF(self.width()/2 +x, self.height()/2 + y))
    #         polygon.append(QtCore.QPointF(x, y))
    #
    #     return polygon</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_horizontal"><code class="name flex">
<span>def <span class="ident">center_horizontal</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_horizontal(self, value):
    self.center_horizontal_value = value
    # print(&#34;horizontal: &#34; + str(self.center_horizontal_value))</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_p"><code class="name flex">
<span>def <span class="ident">center_p</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the center position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_p(self):
    &#34;&#34;&#34;
    Return the center position
    &#34;&#34;&#34;
    return [self.width() * self.cp0[0], self.height() * self.cp0[1]]</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_vertical"><code class="name flex">
<span>def <span class="ident">center_vertical</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_vertical(self, value):
    self.center_vertical_value = value
    # print(&#34;vertical: &#34; + str(self.center_vertical_value))</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.change_value_needle_style"><code class="name flex">
<span>def <span class="ident">change_value_needle_style</span></span>(<span>self, design)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_value_needle_style(self, design):
    # prepared for multiple needle instrument
    self.value_needle = []
    for i in design:
        self.value_needle.append(i)
    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_digital_indicator"><code class="name flex">
<span>def <span class="ident">create_digital_indicator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main value indicator inside the Gauge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_digital_indicator(self):
    &#34;&#34;&#34; Main value indicator inside the Gauge &#34;&#34;&#34;
    painter = QPainter(self)
    # painter.setRenderHint(QPainter.HighQualityAntialiasing)
    painter.setRenderHint(QPainter.Antialiasing)

    # Koordinatenursprung in die Mitte der Flaeche legen
    # Place the coordinate origin in the center
    painter.translate(*self.center_p())
    # painter.save()
    # xShadow = 3.0
    # yShadow = 3.0
    font = QFont(self.value_fontname, self.value_fontsize)
    fm = QFontMetrics(font)

    pen_shadow = QPen()

    pen_shadow.setBrush(self.DisplayValueColor)
    painter.setPen(pen_shadow)

    text_radius = self.widget_diameter / 2 * self.text_radius_factor

    # angle_distance = (float(self.scale_angle_size) / float(self.scala_main_count))
    # for i in range(self.scala_main_count + 1):
    text = str(int(self.value))
    w = fm.width(text) + 1
    h = fm.height()
    painter.setFont(QFont(self.value_fontname, self.value_fontsize))

    # Mitte zwischen Skalenstart und Skalenende:
    # Skalenende = Skalenanfang - 360 + Skalenlaenge
    # Skalenmitte = (Skalenende - Skalenanfang) / 2 + Skalenanfang
    angle_end = float(self.scale_angle_start_value + self.scale_angle_size - 360)
    angle = (
        angle_end - self.scale_angle_start_value
    ) / 2 + self.scale_angle_start_value

    x = text_radius * math.cos(math.radians(angle))
    y = text_radius * math.sin(math.radians(angle))
    # print(w, h, x, y, text)
    text = [x - int(w / 2), y - int(h / 2), int(w), int(h), Qt.AlignCenter, text]
    painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
    # painter.restore()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks"><code class="name flex">
<span>def <span class="ident">create_major_ticks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Painter of the major ticks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_major_ticks(self):
    &#34;&#34;&#34;
    Painter of the major ticks
    &#34;&#34;&#34;
    painter = QPainter(self)
    painter.setRenderHint(QPainter.Antialiasing)
    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())

    # painter.setPen(Qt.NoPen)
    # Major ticks color
    self.pen = QPen(QColor(0, 0, 0, 255))
    self.pen.setWidth(2)
    # # if outline_pen_with &gt; 0:
    painter.setPen(self.pen)

    painter.rotate(self.scale_angle_start_value - self.angle_offset)
    steps_size = float(self.scale_angle_size) / float(self.scala_main_count)
    scale_line_outer_start = self.widget_diameter / 2
    scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 20)
    # print(stepszize)
    for i in range(self.scala_main_count + 1):
        painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
        painter.rotate(steps_size)</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks_labels"><code class="name flex">
<span>def <span class="ident">create_major_ticks_labels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw major ticks labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_major_ticks_labels(self):
    &#34;&#34;&#34;
    Draw major ticks labels
    &#34;&#34;&#34;
    painter = QPainter(self)
    # painter.setRenderHint(QPainter.HighQualityAntialiasing)
    painter.setRenderHint(QPainter.Antialiasing)

    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())
    # painter.save()
    font = QFont(self.scale_fontname, self.scale_fontsize)
    fm = QFontMetrics(font)

    pen_shadow = QPen()

    pen_shadow.setBrush(self.ScaleValueColor)
    painter.setPen(pen_shadow)

    # Scale ticks relative radius
    text_radius_factor = 0.75
    text_radius = self.widget_diameter / 2 * text_radius_factor

    scale_per_div = int((self.value_max - self.value_min) / self.scala_main_count)

    angle_distance = float(self.scale_angle_size) / float(self.scala_main_count)
    for i in range(self.scala_main_count + 1):
        # text = str(int((self.value_max - self.value_min) / self.scala_main_count * i))
        text = str(int(self.value_min + scale_per_div * i))
        w = fm.width(text) + 1
        h = fm.height()
        painter.setFont(QFont(self.scale_fontname, self.scale_fontsize))
        angle = angle_distance * i + float(
            self.scale_angle_start_value - self.angle_offset
        )
        x = text_radius * math.cos(math.radians(angle))
        y = text_radius * math.sin(math.radians(angle))
        # print(w, h, x, y, text)
        text = [
            x - int(w / 2),
            y - int(h / 2),
            int(w),
            int(h),
            Qt.AlignCenter,
            text,
        ]
        painter.drawText(text[0], text[1], text[2], text[3], text[4], text[5])
    # painter.restore()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_minor_ticks"><code class="name flex">
<span>def <span class="ident">create_minor_ticks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_minor_ticks(self):
    #  Description_dict = 0
    painter = QPainter(self)

    painter.setRenderHint(QPainter.Antialiasing)
    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())

    painter.setPen(Qt.black)
    painter.rotate(self.scale_angle_start_value - self.angle_offset)
    steps_size = float(self.scale_angle_size) / float(
        self.scala_main_count * self.scala_subdiv_count
    )
    scale_line_outer_start = self.widget_diameter / 2
    scale_line_lenght = (self.widget_diameter / 2) - (self.widget_diameter / 40)
    for i in range((self.scala_main_count * self.scala_subdiv_count) + 1):
        painter.drawLine(scale_line_lenght, 0, scale_line_outer_start, 0)
        painter.rotate(steps_size)</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_polygon_pie"><code class="name flex">
<span>def <span class="ident">create_polygon_pie</span></span>(<span>self, outer_radius, inner_raduis, start, lenght)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_polygon_pie(self, outer_radius, inner_raduis, start, lenght):
    polygon_pie = QPolygonF()
    # start = self.scale_angle_start_value
    # start = 0
    # lenght = self.scale_angle_size
    # lenght = 180
    # inner_raduis = self.width()/4
    # print(start)
    n = 360  # angle steps size for full circle
    # changing n value will causes drawing issues
    w = 360 / n  # angle per step
    # create outer circle line from &#34;start&#34;-angle to &#34;start + lenght&#34;-angle
    x = 0
    y = 0

    # todo enable/disable bar graf here
    if not self.enable_barGraph:
        # float_value = ((lenght / (self.value_max - self.value_min)) * (self.value - self.value_min))
        lenght = int(
            round(
                (lenght / (self.value_max - self.value_min))
                * (self.value - self.value_min)
            )
        )
        # print(&#34;f: %s, l: %s&#34; %(float_value, lenght))
        pass

    # mymax = 0

    for i in range(lenght + 1):  # add the points of polygon
        t = w * i + start - self.angle_offset
        x = outer_radius * math.cos(math.radians(t))
        y = outer_radius * math.sin(math.radians(t))
        polygon_pie.append(QPointF(x, y))
    # create inner circle line from &#34;start + lenght&#34;-angle to &#34;start&#34;-angle
    for i in range(lenght + 1):  # add the points of polygon
        # print(&#34;2 &#34; + str(i))
        t = w * (lenght - i) + start - self.angle_offset
        x = inner_raduis * math.cos(math.radians(t))
        y = inner_raduis * math.sin(math.radians(t))
        polygon_pie.append(QPointF(x, y))

    # close outer line
    polygon_pie.append(QPointF(x, y))
    return polygon_pie</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_border"><code class="name flex">
<span>def <span class="ident">draw_border</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_border(self):
    painter = QPainter(self)
    painter.setRenderHint(QPainter.Antialiasing)
    painter.translate(*self.center_p())
    painter.setPen(QPen(Qt.green, 3))
    x0, y0 = self.center_p()
    painter.drawRect(0 - x0, 0 - y0, self.width(), self.height())</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_center_point"><code class="name flex">
<span>def <span class="ident">draw_center_point</span></span>(<span>self, diameter=30)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_center_point(self, diameter=30):
    painter = QPainter(self)
    # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
    painter.setRenderHint(QPainter.Antialiasing)

    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())
    painter.setPen(Qt.NoPen)
    # painter.setPen(Qt.NoPen)
    painter.setBrush(self.CenterPointColor)
    # diameter = diameter # self.widget_diameter/6
    painter.drawEllipse(
        int(-diameter / 2), int(-diameter / 2), int(diameter), int(diameter)
    )</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_filled_polygon"><code class="name flex">
<span>def <span class="ident">draw_filled_polygon</span></span>(<span>self, outline_pen_with=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw color gradiate below the scale ticks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_filled_polygon(self, outline_pen_with=0):
    &#34;&#34;&#34; Draw color gradiate below the scale ticks
    &#34;&#34;&#34;
    if self.scale_polygon_colors == None:
        return

    painter = QPainter(self)
    painter.setRenderHint(QPainter.Antialiasing)
    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())

    painter.setPen(Qt.NoPen)

    self.pen.setWidth(outline_pen_with)
    if outline_pen_with &gt; 0:
        painter.setPen(self.pen)

    colored_scale_polygon = self.create_polygon_pie(
        ((self.widget_diameter / 2) - (self.pen.width() / 2))
        * self.gauge_color_outer_radius_factor,
        (
            ((self.widget_diameter / 2) - (self.pen.width() / 2))
            * self.gauge_color_inner_radius_factor
        ),
        self.scale_angle_start_value,
        self.scale_angle_size,
    )

    # gauge_rect seems to be unused.
    # gauge_rect = QRect(QPoint(0, 0), QSize(self.widget_diameter / 2 - 1, self.widget_diameter - 1))
    grad = QConicalGradient(
        QPointF(0, 0),
        -self.scale_angle_size
        - self.scale_angle_start_value
        + self.angle_offset
        - 1,
    )

    # todo definition scale color as array here
    for eachcolor in self.scale_polygon_colors:
        grad.setColorAt(*eachcolor)
    # grad.setColorAt(.00, Qt.red)
    # grad.setColorAt(.1, Qt.yellow)
    # grad.setColorAt(.15, Qt.green)
    # grad.setColorAt(1, Qt.transparent)
    painter.setBrush(grad)
    # self.brush = QBrush(QColor(255, 0, 255, 255))
    # painter.setBrush(self.brush)
    painter.drawPolygon(colored_scale_polygon)
    # return painter</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_needle"><code class="name flex">
<span>def <span class="ident">draw_needle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_needle(self):
    painter = QPainter(self)
    # painter.setRenderHint(QtGui.QPainter.HighQualityAntialiasing)
    painter.setRenderHint(QPainter.Antialiasing)
    # Koordinatenursprung in die Mitte der Flaeche legen
    painter.translate(*self.center_p())
    painter.setPen(Qt.NoPen)
    painter.setBrush(self.NeedleColor)
    painter.rotate(
        (
            (self.value - self.value_offset - self.value_min)
            * self.scale_angle_size
            / (self.value_max - self.value_min)
        )
        + 90
        + self.scale_angle_start_value
    )

    painter.drawConvexPolygon(self.value_needle[0])</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.get_value_max"><code class="name flex">
<span>def <span class="ident">get_value_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_max(self):
    return self.value_max</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseMoveEvent(self, QMouseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    x, y = event.x() - (self.width() / 2), event.y() - (self.height() / 2)
    if not x == 0:
        angle = math.atan2(y, x) / math.pi * 180
        # winkellaenge der anzeige immer positiv 0 - 360deg
        # min wert + umskalierter wert
        value = (
            float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
            / (
                float(self.scale_angle_size)
                / float(self.value_max - self.value_min)
            )
        ) + self.value_min
        temp = value
        fmod = float(math.fmod(angle - self.scale_angle_start_value + 720, 360))
        state = 0
        if (
            (
                self.value
                - (self.value_max - self.value_min) * self.value_needle_snapzone
            )
            &lt;= value
            &lt;= (
                self.value
                + (self.value_max - self.value_min) * self.value_needle_snapzone
            )
        ):
            self.NeedleColor = self.NeedleColorDrag
            # todo: evtl ueberpruefen
            #
            state = 9
            # if value &gt;= self.value_max and self.last_value &lt; (self.value_max - self.value_min) / 2:
            if (
                value &gt;= self.value_max
                and self.last_value &lt; (self.value_max - self.value_min) / 2
            ):
                state = 1
                value = self.value_max
                self.last_value = self.value_min
                self.valueChanged.emit(int(value))
            elif value &gt;= self.value_max &gt;= self.last_value:
                state = 2
                value = self.value_max
                self.last_value = self.value_max
                self.valueChanged.emit(int(value))
            else:
                state = 3
                self.last_value = value
                self.valueChanged.emit(int(value))

            # todo: mouse event debug output

            # self.update_value(value, mouse_controlled=True)

            # self.valueChanged.emit(int(value))
            # print(str(int(value)))
        # self.valueChanged.emit()

        # todo: convert print to logging debug
        # print(&#39;mouseMoveEvent: x=%d, y=%d, a=%s, v=%s, fmod=%s, temp=%s, state=%s&#39; % (
        #     x, y, angle, value, fmod, temp, state))</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseReleaseEvent"><code class="name flex">
<span>def <span class="ident">mouseReleaseEvent</span></span>(<span>self, QMouseEvent)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseReleaseEvent(self, QMouseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseReleaseEvent(self, QMouseEvent):
    # print(&#34;released&#34;)
    self.NeedleColor = self.NeedleColorReleased

    if not self.use_timer_event:
        self.update()
    pass</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>paintEvent(self, QPaintEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event):
    # Main Drawing Event:
    # Will be executed on every change
    # vgl http://doc.qt.io/qt-4.8/qt-demos-affine-xform-cpp.html
    # print(&#34;event&#34;, event)

    # colored scale
    if self.enable_filled_Polygon:
        self.draw_filled_polygon()

    # draw scale ticks
    if self.enable_fine_scaled_marker:
        self.create_minor_ticks()
    if self.enable_big_scaled_marker:
        self.create_major_ticks()

    # draw tick labels
    if self.enable_scale_text:
        self.create_major_ticks_labels()

    # Display Value in the digital indicator
    if self.enable_value_text:
        self.create_digital_indicator()

    # draw needle 1
    if self.enable_Needle_Polygon:
        self.draw_needle()

    # Draw Center Point
    if self.enable_CenterPoint:
        self.draw_center_point(diameter=(self.widget_diameter / 6))

    # Draw border of the widget
    # self.draw_border()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.rescale_method"><code class="name flex">
<span>def <span class="ident">rescale_method</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescale_method(self):
    # print(&#34;slotMethod&#34;)
    ysize = 1.7 * self.height()
    if self.width() &lt;= ysize:
        self.widget_diameter = self.width()
    else:
        self.widget_diameter = ysize

    self.change_value_needle_style(
        [
            QPolygon(
                [
                    QPoint(4, 30),
                    QPoint(-4, 30),
                    QPoint(
                        -2, -self.widget_diameter / 2 * self.needle_scale_factor
                    ),
                    QPoint(
                        0, -self.widget_diameter / 2 * self.needle_scale_factor - 6
                    ),
                    QPoint(2, -self.widget_diameter / 2 * self.needle_scale_factor),
                ]
            )
        ]
    )
    # needle = [QPolygon([
    #     QPoint(4, 4),
    #     QPoint(-4, 4),
    #     QPoint(-3, -120),
    #     QPoint(0, -126),
    #     QPoint(3, -120)])]
    # print(str(type(needle)).split(&#34;&#39;&#34;)[1])
    #
    # needle = [2]
    # print(str(type(needle[0])).split(&#34;&#39;&#34;)[1])

    self.scale_fontsize = self.initial_scale_fontsize * self.widget_diameter / 250
    self.value_fontsize = self.initial_value_fontsize * self.widget_diameter / 400

    # print(&#34;slotMethod end&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>resizeEvent(self, QResizeEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event):
    # self.resized.emit()
    # return super(self.parent, self).resizeEvent(event)
    # print(&#34;resized&#34;)
    # print(self.width())
    self.rescale_method()
    # self.emit(QtCore.SIGNAL(&#34;resize()&#34;))
    # print(&#34;resizeEvent&#34;)</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.setMouseTracking"><code class="name flex">
<span>def <span class="ident">setMouseTracking</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"><p>setMouseTracking(self, bool)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMouseTracking(self, flag):
    def recursive_set(parent):
        for child in parent.findChildren(QObject):
            try:
                child.setMouseTracking(flag)
            except:
                pass
            recursive_set(child)

    QWidget.setMouseTracking(self, flag)
    recursive_set(self)</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_CenterPointColor"><code class="name flex">
<span>def <span class="ident">set_CenterPointColor</span></span>(<span>self, R=50, G=50, B=50, Transparency=255)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_CenterPointColor(self, R=50, G=50, B=50, Transparency=255):
    self.CenterPointColor = QColor(R, G, B, Transparency)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_DisplayValueColor"><code class="name flex">
<span>def <span class="ident">set_DisplayValueColor</span></span>(<span>self, R=50, G=50, B=50, Transparency=255)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_DisplayValueColor(self, R=50, G=50, B=50, Transparency=255):
    # Red: R = 0 - 255
    # Green: G = 0 - 255
    # Blue: B = 0 - 255
    # Transparency = 0 - 255
    self.DisplayValueColor = QColor(R, G, B, Transparency)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MaxValue"><code class="name flex">
<span>def <span class="ident">set_MaxValue</span></span>(<span>self, max)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_MaxValue(self, max):
    if self.value &gt; max:
        self.value = max
    if max &lt;= self.value_min:
        self.value_max = self.value_min + 1
    else:
        self.value_max = max

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MinValue"><code class="name flex">
<span>def <span class="ident">set_MinValue</span></span>(<span>self, min)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_MinValue(self, min):
    if self.value &lt; min:
        self.value = min
    if min &gt;= self.value_max:
        self.value_min = self.value_max - 1
    else:
        self.value_min = min

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColor"><code class="name flex">
<span>def <span class="ident">set_NeedleColor</span></span>(<span>self, R=50, G=50, B=50, Transparency=255)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_NeedleColor(self, R=50, G=50, B=50, Transparency=255):
    # Red: R = 0 - 255
    # Green: G = 0 - 255
    # Blue: B = 0 - 255
    # Transparency = 0 - 255
    self.NeedleColor = QColor(R, G, B, Transparency)
    self.NeedleColorReleased = self.NeedleColor

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColorDrag"><code class="name flex">
<span>def <span class="ident">set_NeedleColorDrag</span></span>(<span>self, R=50, G=50, B=50, Transparency=255)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_NeedleColorDrag(self, R=50, G=50, B=50, Transparency=255):
    # Red: R = 0 - 255
    # Green: G = 0 - 255
    # Blue: B = 0 - 255
    # Transparency = 0 - 255
    self.NeedleColorDrag = QColor(R, G, B, Transparency)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_ScaleValueColor"><code class="name flex">
<span>def <span class="ident">set_ScaleValueColor</span></span>(<span>self, R=50, G=50, B=50, Transparency=255)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ScaleValueColor(self, R=50, G=50, B=50, Transparency=255):
    # Red: R = 0 - 255
    # Green: G = 0 - 255
    # Blue: B = 0 - 255
    # Transparency = 0 - 255
    self.ScaleValueColor = QColor(R, G, B, Transparency)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_CenterPoint"><code class="name flex">
<span>def <span class="ident">set_enable_CenterPoint</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_CenterPoint(self, enable=True):
    self.enable_CenterPoint = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_Needle_Polygon"><code class="name flex">
<span>def <span class="ident">set_enable_Needle_Polygon</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_Needle_Polygon(self, enable=True):
    self.enable_Needle_Polygon = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_ScaleText"><code class="name flex">
<span>def <span class="ident">set_enable_ScaleText</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_ScaleText(self, enable=True):
    self.enable_scale_text = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_barGraph"><code class="name flex">
<span>def <span class="ident">set_enable_barGraph</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_barGraph(self, enable=True):
    self.enable_barGraph = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_big_scaled_grid"><code class="name flex">
<span>def <span class="ident">set_enable_big_scaled_grid</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_big_scaled_grid(self, enable=True):
    self.enable_big_scaled_marker = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_filled_Polygon"><code class="name flex">
<span>def <span class="ident">set_enable_filled_Polygon</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_filled_Polygon(self, enable=True):
    self.enable_filled_Polygon = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_fine_scaled_marker"><code class="name flex">
<span>def <span class="ident">set_enable_fine_scaled_marker</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_fine_scaled_marker(self, enable=True):
    self.enable_fine_scaled_marker = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_value_text"><code class="name flex">
<span>def <span class="ident">set_enable_value_text</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_enable_value_text(self, enable=True):
    self.enable_value_text = enable

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_inner_radius_factor"><code class="name flex">
<span>def <span class="ident">set_gauge_color_inner_radius_factor</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gauge_color_inner_radius_factor(self, value):
    self.gauge_color_inner_radius_factor = float(value) / 1000
    # print(self.gauge_color_inner_radius_factor)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_outer_radius_factor"><code class="name flex">
<span>def <span class="ident">set_gauge_color_outer_radius_factor</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gauge_color_outer_radius_factor(self, value):
    self.gauge_color_outer_radius_factor = float(value) / 1000
    # print(self.gauge_color_outer_radius_factor)

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scala_main_count"><code class="name flex">
<span>def <span class="ident">set_scala_main_count</span></span>(<span>self, count)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scala_main_count(self, count):
    if count &lt; 1:
        count = 1
    self.scala_main_count = count

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scale_polygon_colors"><code class="name flex">
<span>def <span class="ident">set_scale_polygon_colors</span></span>(<span>self, color_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scale_polygon_colors(self, color_array):
    # print(type(color_array))
    if &#34;list&#34; in str(type(color_array)):
        self.scale_polygon_colors = color_array
    elif color_array == None:
        self.scale_polygon_colors = [[0.0, Qt.transparent]]
    else:
        self.scale_polygon_colors = [[0.0, Qt.transparent]]

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_start_scale_angle"><code class="name flex">
<span>def <span class="ident">set_start_scale_angle</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_start_scale_angle(self, value):
    # Value range in DEG: 0 - 360
    self.scale_angle_start_value = value
    # print(&#34;startFill: &#34; + str(self.scale_angle_start_value))

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_total_scale_angle_size"><code class="name flex">
<span>def <span class="ident">set_total_scale_angle_size</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_total_scale_angle_size(self, value):
    self.scale_angle_size = value
    # print(&#34;stopFill: &#34; + str(self.scale_angle_size))

    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_angle_offset"><code class="name flex">
<span>def <span class="ident">update_angle_offset</span></span>(<span>self, offset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_angle_offset(self, offset):
    self.angle_offset = offset
    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_value"><code class="name flex">
<span>def <span class="ident">update_value</span></span>(<span>self, value, mouse_controlled=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_value(self, value, mouse_controlled=False):
    # if not mouse_controlled:
    #     self.value = value
    #
    # if mouse_controlled:
    #     self.valueChanged.emit(int(value))

    if value &lt;= self.value_min:
        self.value = self.value_min
    elif value &gt;= self.value_max:
        self.value = self.value_max
    else:
        self.value = value
    # self.paintEvent(&#34;&#34;)
    self.valueChanged.emit(int(value))
    # print(self.value)

    # ohne timer: aktiviere self.update()
    if not self.use_timer_event:
        self.update()</code></pre>
</details>
</dd>
<dt id="controlunit.components.analoggaugewidget.AnalogGaugeWidget.valueChanged"><code class="name flex">
<span>def <span class="ident">valueChanged</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="controlunit.components" href="index.html">controlunit.components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget">AnalogGaugeWidget</a></code></h4>
<ul class="">
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_horizontal" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_horizontal">center_horizontal</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_p" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_p">center_p</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_vertical" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.center_vertical">center_vertical</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.change_value_needle_style" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.change_value_needle_style">change_value_needle_style</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_digital_indicator" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_digital_indicator">create_digital_indicator</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks">create_major_ticks</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks_labels" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_major_ticks_labels">create_major_ticks_labels</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_minor_ticks" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_minor_ticks">create_minor_ticks</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_polygon_pie" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.create_polygon_pie">create_polygon_pie</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_border" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_border">draw_border</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_center_point" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_center_point">draw_center_point</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_filled_polygon" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_filled_polygon">draw_filled_polygon</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_needle" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.draw_needle">draw_needle</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.get_value_max" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.get_value_max">get_value_max</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseMoveEvent" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseMoveEvent">mouseMoveEvent</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseReleaseEvent" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.mouseReleaseEvent">mouseReleaseEvent</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.paintEvent" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.paintEvent">paintEvent</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.rescale_method" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.rescale_method">rescale_method</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.resizeEvent" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.setMouseTracking" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.setMouseTracking">setMouseTracking</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_CenterPointColor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_CenterPointColor">set_CenterPointColor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_DisplayValueColor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_DisplayValueColor">set_DisplayValueColor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MaxValue" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MaxValue">set_MaxValue</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MinValue" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_MinValue">set_MinValue</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColor">set_NeedleColor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColorDrag" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_NeedleColorDrag">set_NeedleColorDrag</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_ScaleValueColor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_ScaleValueColor">set_ScaleValueColor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_CenterPoint" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_CenterPoint">set_enable_CenterPoint</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_Needle_Polygon" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_Needle_Polygon">set_enable_Needle_Polygon</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_ScaleText" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_ScaleText">set_enable_ScaleText</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_barGraph" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_barGraph">set_enable_barGraph</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_big_scaled_grid" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_big_scaled_grid">set_enable_big_scaled_grid</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_filled_Polygon" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_filled_Polygon">set_enable_filled_Polygon</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_fine_scaled_marker" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_fine_scaled_marker">set_enable_fine_scaled_marker</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_value_text" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_enable_value_text">set_enable_value_text</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_inner_radius_factor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_inner_radius_factor">set_gauge_color_inner_radius_factor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_outer_radius_factor" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_gauge_color_outer_radius_factor">set_gauge_color_outer_radius_factor</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scala_main_count" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scala_main_count">set_scala_main_count</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scale_polygon_colors" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_scale_polygon_colors">set_scale_polygon_colors</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_start_scale_angle" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_start_scale_angle">set_start_scale_angle</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_total_scale_angle_size" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.set_total_scale_angle_size">set_total_scale_angle_size</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_angle_offset" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_angle_offset">update_angle_offset</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_value" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.update_value">update_value</a></code></li>
<li><code><a title="controlunit.components.analoggaugewidget.AnalogGaugeWidget.valueChanged" href="#controlunit.components.analoggaugewidget.AnalogGaugeWidget.valueChanged">valueChanged</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>