<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>controlunit.components.dateaxis API documentation</title>
<meta name="description" content="This module provides date-time aware axis" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>controlunit.components.dateaxis</code></h1>
</header>
<section id="section-intro">
<p>This module provides date-time aware axis</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

#############################################################################
#
# This file was adapted from Taurus TEP17, but all taurus dependencies were
# removed so that it works with just pyqtgraph
#
# Just run it and play with the zoom to see how the labels and tick positions
# automatically adapt to the shown range
#
#############################################################################
# http://taurus-scada.org
#
# Copyright 2011 CELLS / ALBA Synchrotron, Bellaterra, Spain
#
# Taurus is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Taurus is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Taurus.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#############################################################################

&#34;&#34;&#34;
This module provides date-time aware axis
&#34;&#34;&#34;

__all__ = [&#34;DateAxisItem&#34;]

import numpy
from pyqtgraph import AxisItem
from datetime import datetime, timedelta
from time import mktime


class DateAxisItem(AxisItem):
    &#34;&#34;&#34;
    A tool that provides a date-time aware axis. It is implemented as an
    AxisItem that interpretes positions as unix timestamps (i.e. seconds
    since 1970).
    The labels and the tick positions are dynamically adjusted depending
    on the range.
    It provides a  :meth:`attachToPlotItem` method to add it to a given
    PlotItem
    &#34;&#34;&#34;

    # Max width in pixels reserved for each label in axis
    _pxLabelWidth = 80

    def __init__(self, *args, **kwargs):
        AxisItem.__init__(self, *args, **kwargs)
        self._oldAxis = None

    def tickValues(self, minVal, maxVal, size):
        &#34;&#34;&#34;
        Reimplemented from PlotItem to adjust to the range and to force
        the ticks at &#34;round&#34; positions in the context of time units instead of
        rounding in a decimal base
        &#34;&#34;&#34;

        maxMajSteps = int(size / self._pxLabelWidth)

        dt1 = datetime.fromtimestamp(minVal)
        dt2 = datetime.fromtimestamp(maxVal)

        dx = maxVal - minVal
        majticks = []

        if dx &gt; 63072001:  # 3600s*24*(365+366) = 2 years (count leap year)
            d = timedelta(days=366)
            for y in range(dt1.year + 1, dt2.year):
                dt = datetime(year=y, month=1, day=1)
                majticks.append(mktime(dt.timetuple()))

        elif dx &gt; 5270400:  # 3600s*24*61 = 61 days
            d = timedelta(days=31)
            dt = dt1.replace(day=1, hour=0, minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                # make sure that we are on day 1 (even if always sum 31 days)
                dt = dt.replace(day=1)
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 172800:  # 3600s24*2 = 2 days
            d = timedelta(days=1)
            dt = dt1.replace(hour=0, minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 7200:  # 3600s*2 = 2hours
            d = timedelta(hours=1)
            dt = dt1.replace(minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 1200:  # 60s*20 = 20 minutes
            d = timedelta(minutes=10)
            dt = (
                dt1.replace(minute=(dt1.minute // 10) * 10, second=0, microsecond=0) + d
            )
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 120:  # 60s*2 = 2 minutes
            d = timedelta(minutes=1)
            dt = dt1.replace(second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 20:  # 20s
            d = timedelta(seconds=10)
            dt = dt1.replace(second=(dt1.second // 10) * 10, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 2:  # 2s
            d = timedelta(seconds=1)
            majticks = range(int(minVal), int(maxVal))

        else:  # &lt;2s , use standard implementation from parent
            return AxisItem.tickValues(self, minVal, maxVal, size)

        L = len(majticks)
        if L &gt; maxMajSteps:
            majticks = majticks[:: int(numpy.ceil(float(L) / maxMajSteps))]

        return [(d.total_seconds(), majticks)]

    def tickStrings(self, values, scale, spacing):
        &#34;&#34;&#34;Reimplemented from PlotItem to adjust to the range&#34;&#34;&#34;
        ret = []
        if not values:
            return []

        if spacing &gt;= 31622400:  # 366 days
            fmt = &#34;%Y&#34;

        elif spacing &gt;= 2678400:  # 31 days
            fmt = &#34;%Y %b&#34;

        elif spacing &gt;= 86400:  # = 1 day
            fmt = &#34;%b/%d&#34;

        elif spacing &gt;= 3600:  # 1 h
            fmt = &#34;%b/%d-%Hh&#34;

        elif spacing &gt;= 60:  # 1 m
            fmt = &#34;%H:%M&#34;

        elif spacing &gt;= 1:  # 1s
            fmt = &#34;%H:%M:%S&#34;

        else:
            # less than 2s (show microseconds)
            # fmt = &#39;%S.%f&#34;&#39;
            fmt = &#34;[+%fms]&#34;  # explicitly relative to last second

        for x in values:
            try:
                t = datetime.fromtimestamp(x)
                ret.append(t.strftime(fmt))
            except ValueError:  # Windows can&#39;t handle dates before 1970
                ret.append(&#34;&#34;)

        return ret

    def attachToPlotItem(self, plotItem):
        &#34;&#34;&#34;Add this axis to the given PlotItem
        :param plotItem: (PlotItem)
        &#34;&#34;&#34;
        self.setParentItem(plotItem)
        viewBox = plotItem.getViewBox()
        self.linkToView(viewBox)
        self._oldAxis = plotItem.axes[self.orientation][&#34;item&#34;]
        self._oldAxis.hide()
        plotItem.axes[self.orientation][&#34;item&#34;] = self
        pos = plotItem.axes[self.orientation][&#34;pos&#34;]
        plotItem.layout.addItem(self, *pos)
        self.setZValue(-1000)

    def detachFromPlotItem(self):
        &#34;&#34;&#34;Remove this axis from its attached PlotItem
        (not yet implemented)
        &#34;&#34;&#34;
        raise NotImplementedError()  # TODO


if __name__ == &#34;__main__&#34;:

    import time
    import sys
    import pyqtgraph as pg
    from PyQt5 import QtGui

    app = QtGui.QApplication([])

    w = pg.PlotWidget()

    # Add the Date-time axis
    axis = DateAxisItem(orientation=&#34;bottom&#34;)
    axis.attachToPlotItem(w.getPlotItem())

    # plot some random data with timestamps in the last hour
    now = time.time()
    timestamps = numpy.linspace(now - 3600, now, 100)
    w.plot(x=timestamps, y=numpy.random.rand(100), symbol=&#34;o&#34;)

    w.show()

    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="controlunit.components.dateaxis.DateAxisItem"><code class="flex name class">
<span>class <span class="ident">DateAxisItem</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A tool that provides a date-time aware axis. It is implemented as an
AxisItem that interpretes positions as unix timestamps (i.e. seconds
since 1970).
The labels and the tick positions are dynamically adjusted depending
on the range.
It provides a
:meth:<code>attachToPlotItem</code> method to add it to a given
PlotItem</p>
<p>==============
===============================================================
<strong>Arguments:</strong>
orientation
one of 'left', 'right', 'top', or 'bottom'
maxTickLength
(px) maximum length of ticks to draw. Negative values draw
into the plot, positive values draw outward.
linkView
(ViewBox) causes the range of values displayed in the axis
to be linked to the visible range of a ViewBox.
showValues
(bool) Whether to display values adjacent to ticks
pen
(QPen) Pen used when drawing ticks.
textPen
(QPen) Pen used when drawing tick labels.
text
The text (excluding units) to display on the label for this
axis.
units
The units for this axis. Units should generally be given
without any scaling prefix (eg, 'V' instead of 'mV'). The
scaling prefix will be automatically prepended based on the
range of data displayed.
args
All extra keyword arguments become CSS style options for
the <span> tag which will surround the axis label and units.
==============
===============================================================</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateAxisItem(AxisItem):
    &#34;&#34;&#34;
    A tool that provides a date-time aware axis. It is implemented as an
    AxisItem that interpretes positions as unix timestamps (i.e. seconds
    since 1970).
    The labels and the tick positions are dynamically adjusted depending
    on the range.
    It provides a  :meth:`attachToPlotItem` method to add it to a given
    PlotItem
    &#34;&#34;&#34;

    # Max width in pixels reserved for each label in axis
    _pxLabelWidth = 80

    def __init__(self, *args, **kwargs):
        AxisItem.__init__(self, *args, **kwargs)
        self._oldAxis = None

    def tickValues(self, minVal, maxVal, size):
        &#34;&#34;&#34;
        Reimplemented from PlotItem to adjust to the range and to force
        the ticks at &#34;round&#34; positions in the context of time units instead of
        rounding in a decimal base
        &#34;&#34;&#34;

        maxMajSteps = int(size / self._pxLabelWidth)

        dt1 = datetime.fromtimestamp(minVal)
        dt2 = datetime.fromtimestamp(maxVal)

        dx = maxVal - minVal
        majticks = []

        if dx &gt; 63072001:  # 3600s*24*(365+366) = 2 years (count leap year)
            d = timedelta(days=366)
            for y in range(dt1.year + 1, dt2.year):
                dt = datetime(year=y, month=1, day=1)
                majticks.append(mktime(dt.timetuple()))

        elif dx &gt; 5270400:  # 3600s*24*61 = 61 days
            d = timedelta(days=31)
            dt = dt1.replace(day=1, hour=0, minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                # make sure that we are on day 1 (even if always sum 31 days)
                dt = dt.replace(day=1)
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 172800:  # 3600s24*2 = 2 days
            d = timedelta(days=1)
            dt = dt1.replace(hour=0, minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 7200:  # 3600s*2 = 2hours
            d = timedelta(hours=1)
            dt = dt1.replace(minute=0, second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 1200:  # 60s*20 = 20 minutes
            d = timedelta(minutes=10)
            dt = (
                dt1.replace(minute=(dt1.minute // 10) * 10, second=0, microsecond=0) + d
            )
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 120:  # 60s*2 = 2 minutes
            d = timedelta(minutes=1)
            dt = dt1.replace(second=0, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 20:  # 20s
            d = timedelta(seconds=10)
            dt = dt1.replace(second=(dt1.second // 10) * 10, microsecond=0) + d
            while dt &lt; dt2:
                majticks.append(mktime(dt.timetuple()))
                dt += d

        elif dx &gt; 2:  # 2s
            d = timedelta(seconds=1)
            majticks = range(int(minVal), int(maxVal))

        else:  # &lt;2s , use standard implementation from parent
            return AxisItem.tickValues(self, minVal, maxVal, size)

        L = len(majticks)
        if L &gt; maxMajSteps:
            majticks = majticks[:: int(numpy.ceil(float(L) / maxMajSteps))]

        return [(d.total_seconds(), majticks)]

    def tickStrings(self, values, scale, spacing):
        &#34;&#34;&#34;Reimplemented from PlotItem to adjust to the range&#34;&#34;&#34;
        ret = []
        if not values:
            return []

        if spacing &gt;= 31622400:  # 366 days
            fmt = &#34;%Y&#34;

        elif spacing &gt;= 2678400:  # 31 days
            fmt = &#34;%Y %b&#34;

        elif spacing &gt;= 86400:  # = 1 day
            fmt = &#34;%b/%d&#34;

        elif spacing &gt;= 3600:  # 1 h
            fmt = &#34;%b/%d-%Hh&#34;

        elif spacing &gt;= 60:  # 1 m
            fmt = &#34;%H:%M&#34;

        elif spacing &gt;= 1:  # 1s
            fmt = &#34;%H:%M:%S&#34;

        else:
            # less than 2s (show microseconds)
            # fmt = &#39;%S.%f&#34;&#39;
            fmt = &#34;[+%fms]&#34;  # explicitly relative to last second

        for x in values:
            try:
                t = datetime.fromtimestamp(x)
                ret.append(t.strftime(fmt))
            except ValueError:  # Windows can&#39;t handle dates before 1970
                ret.append(&#34;&#34;)

        return ret

    def attachToPlotItem(self, plotItem):
        &#34;&#34;&#34;Add this axis to the given PlotItem
        :param plotItem: (PlotItem)
        &#34;&#34;&#34;
        self.setParentItem(plotItem)
        viewBox = plotItem.getViewBox()
        self.linkToView(viewBox)
        self._oldAxis = plotItem.axes[self.orientation][&#34;item&#34;]
        self._oldAxis.hide()
        plotItem.axes[self.orientation][&#34;item&#34;] = self
        pos = plotItem.axes[self.orientation][&#34;pos&#34;]
        plotItem.layout.addItem(self, *pos)
        self.setZValue(-1000)

    def detachFromPlotItem(self):
        &#34;&#34;&#34;Remove this axis from its attached PlotItem
        (not yet implemented)
        &#34;&#34;&#34;
        raise NotImplementedError()  # TODO</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyqtgraph.graphicsItems.AxisItem.AxisItem</li>
<li>pyqtgraph.graphicsItems.GraphicsWidget.GraphicsWidget</li>
<li>pyqtgraph.graphicsItems.GraphicsItem.GraphicsItem</li>
<li>PyQt5.QtWidgets.QGraphicsWidget</li>
<li>PyQt5.QtWidgets.QGraphicsObject</li>
<li>PyQt5.QtCore.QObject</li>
<li>PyQt5.QtWidgets.QGraphicsItem</li>
<li>PyQt5.QtWidgets.QGraphicsLayoutItem</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="controlunit.components.dateaxis.DateAxisItem.attachToPlotItem"><code class="name flex">
<span>def <span class="ident">attachToPlotItem</span></span>(<span>self, plotItem)</span>
</code></dt>
<dd>
<div class="desc"><p>Add this axis to the given PlotItem
:param plotItem: (PlotItem)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attachToPlotItem(self, plotItem):
    &#34;&#34;&#34;Add this axis to the given PlotItem
    :param plotItem: (PlotItem)
    &#34;&#34;&#34;
    self.setParentItem(plotItem)
    viewBox = plotItem.getViewBox()
    self.linkToView(viewBox)
    self._oldAxis = plotItem.axes[self.orientation][&#34;item&#34;]
    self._oldAxis.hide()
    plotItem.axes[self.orientation][&#34;item&#34;] = self
    pos = plotItem.axes[self.orientation][&#34;pos&#34;]
    plotItem.layout.addItem(self, *pos)
    self.setZValue(-1000)</code></pre>
</details>
</dd>
<dt id="controlunit.components.dateaxis.DateAxisItem.detachFromPlotItem"><code class="name flex">
<span>def <span class="ident">detachFromPlotItem</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove this axis from its attached PlotItem
(not yet implemented)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detachFromPlotItem(self):
    &#34;&#34;&#34;Remove this axis from its attached PlotItem
    (not yet implemented)
    &#34;&#34;&#34;
    raise NotImplementedError()  # TODO</code></pre>
</details>
</dd>
<dt id="controlunit.components.dateaxis.DateAxisItem.tickStrings"><code class="name flex">
<span>def <span class="ident">tickStrings</span></span>(<span>self, values, scale, spacing)</span>
</code></dt>
<dd>
<div class="desc"><p>Reimplemented from PlotItem to adjust to the range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tickStrings(self, values, scale, spacing):
    &#34;&#34;&#34;Reimplemented from PlotItem to adjust to the range&#34;&#34;&#34;
    ret = []
    if not values:
        return []

    if spacing &gt;= 31622400:  # 366 days
        fmt = &#34;%Y&#34;

    elif spacing &gt;= 2678400:  # 31 days
        fmt = &#34;%Y %b&#34;

    elif spacing &gt;= 86400:  # = 1 day
        fmt = &#34;%b/%d&#34;

    elif spacing &gt;= 3600:  # 1 h
        fmt = &#34;%b/%d-%Hh&#34;

    elif spacing &gt;= 60:  # 1 m
        fmt = &#34;%H:%M&#34;

    elif spacing &gt;= 1:  # 1s
        fmt = &#34;%H:%M:%S&#34;

    else:
        # less than 2s (show microseconds)
        # fmt = &#39;%S.%f&#34;&#39;
        fmt = &#34;[+%fms]&#34;  # explicitly relative to last second

    for x in values:
        try:
            t = datetime.fromtimestamp(x)
            ret.append(t.strftime(fmt))
        except ValueError:  # Windows can&#39;t handle dates before 1970
            ret.append(&#34;&#34;)

    return ret</code></pre>
</details>
</dd>
<dt id="controlunit.components.dateaxis.DateAxisItem.tickValues"><code class="name flex">
<span>def <span class="ident">tickValues</span></span>(<span>self, minVal, maxVal, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Reimplemented from PlotItem to adjust to the range and to force
the ticks at "round" positions in the context of time units instead of
rounding in a decimal base</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tickValues(self, minVal, maxVal, size):
    &#34;&#34;&#34;
    Reimplemented from PlotItem to adjust to the range and to force
    the ticks at &#34;round&#34; positions in the context of time units instead of
    rounding in a decimal base
    &#34;&#34;&#34;

    maxMajSteps = int(size / self._pxLabelWidth)

    dt1 = datetime.fromtimestamp(minVal)
    dt2 = datetime.fromtimestamp(maxVal)

    dx = maxVal - minVal
    majticks = []

    if dx &gt; 63072001:  # 3600s*24*(365+366) = 2 years (count leap year)
        d = timedelta(days=366)
        for y in range(dt1.year + 1, dt2.year):
            dt = datetime(year=y, month=1, day=1)
            majticks.append(mktime(dt.timetuple()))

    elif dx &gt; 5270400:  # 3600s*24*61 = 61 days
        d = timedelta(days=31)
        dt = dt1.replace(day=1, hour=0, minute=0, second=0, microsecond=0) + d
        while dt &lt; dt2:
            # make sure that we are on day 1 (even if always sum 31 days)
            dt = dt.replace(day=1)
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 172800:  # 3600s24*2 = 2 days
        d = timedelta(days=1)
        dt = dt1.replace(hour=0, minute=0, second=0, microsecond=0) + d
        while dt &lt; dt2:
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 7200:  # 3600s*2 = 2hours
        d = timedelta(hours=1)
        dt = dt1.replace(minute=0, second=0, microsecond=0) + d
        while dt &lt; dt2:
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 1200:  # 60s*20 = 20 minutes
        d = timedelta(minutes=10)
        dt = (
            dt1.replace(minute=(dt1.minute // 10) * 10, second=0, microsecond=0) + d
        )
        while dt &lt; dt2:
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 120:  # 60s*2 = 2 minutes
        d = timedelta(minutes=1)
        dt = dt1.replace(second=0, microsecond=0) + d
        while dt &lt; dt2:
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 20:  # 20s
        d = timedelta(seconds=10)
        dt = dt1.replace(second=(dt1.second // 10) * 10, microsecond=0) + d
        while dt &lt; dt2:
            majticks.append(mktime(dt.timetuple()))
            dt += d

    elif dx &gt; 2:  # 2s
        d = timedelta(seconds=1)
        majticks = range(int(minVal), int(maxVal))

    else:  # &lt;2s , use standard implementation from parent
        return AxisItem.tickValues(self, minVal, maxVal, size)

    L = len(majticks)
    if L &gt; maxMajSteps:
        majticks = majticks[:: int(numpy.ceil(float(L) / maxMajSteps))]

    return [(d.total_seconds(), majticks)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="controlunit.components" href="index.html">controlunit.components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="controlunit.components.dateaxis.DateAxisItem" href="#controlunit.components.dateaxis.DateAxisItem">DateAxisItem</a></code></h4>
<ul class="">
<li><code><a title="controlunit.components.dateaxis.DateAxisItem.attachToPlotItem" href="#controlunit.components.dateaxis.DateAxisItem.attachToPlotItem">attachToPlotItem</a></code></li>
<li><code><a title="controlunit.components.dateaxis.DateAxisItem.detachFromPlotItem" href="#controlunit.components.dateaxis.DateAxisItem.detachFromPlotItem">detachFromPlotItem</a></code></li>
<li><code><a title="controlunit.components.dateaxis.DateAxisItem.tickStrings" href="#controlunit.components.dateaxis.DateAxisItem.tickStrings">tickStrings</a></code></li>
<li><code><a title="controlunit.components.dateaxis.DateAxisItem.tickValues" href="#controlunit.components.dateaxis.DateAxisItem.tickValues">tickValues</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>